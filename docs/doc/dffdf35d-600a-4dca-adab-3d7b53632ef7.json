{
    "summary": "The code features data processing functions, interval tuple merging, dictionary range consolidation, and time span sorting, with additional capabilities for handling coordinates, Bezier curves, and calculating max cursor average in a window.",
    "details": [
        {
            "comment": "- Defines functions for range extraction, convolution, and truncated normal distribution.\n- Uses itertools groupby for range extraction.\n- Convolution applies a simple moving average without considering tail values.\n- Truncated normal distribution uses scipy's truncnorm function with assertions to validate input.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":0-34",
            "content": "# not overriding math.\n# do some ranged stuff here...\nfrom itertools import groupby\ndef extract_span(mlist, target=0):\n    counter = 0\n    spanList = []\n    target_list = [(a, len(list(b))) for a, b in groupby(mlist)]\n    for a, b in target_list:\n        nextCounter = counter + b\n        if a == target:\n            spanList.append((counter, nextCounter))\n        counter = nextCounter\n    return spanList\ndef convoluted(array, k=2, pad=0):  # simple convolution. no tail.\n    pad_size = k - 1\n    new_array = [pad] * pad_size + array\n    result = []\n    for i in range(len(array)):\n        sliced = new_array[i : i + k]\n        value = sum(sliced) / k\n        result.append(value)\n    return result\ndef getTruncatedNormalDistribution(std, mean, start, end, evaluate=False):\n    # std, mean = gaussian_args[\"std\"], gaussian_args[\"mean\"]\n    assert start < end\n    assert std > 0\n    scale, loc = std, mean\n    myclip_a, myclip_b = start, end\n    from scipy.stats import truncnorm\n    a, b = (myclip_a - loc) / scale, (myclip_b - loc) / scale"
        },
        {
            "comment": "This code snippet defines a function `checkMinMaxDict` that takes in a value and a dictionary `minMaxDict` with keys \"min\" and \"max\". It checks if the value is within the specified minimum and maximum values. If the `evaluate` flag is set, it returns a randomly generated value based on the `minMaxDict`, otherwise it just returns the function for evaluation. The code also includes error handling to ensure correct usage of the dictionary and handles non-numeric values.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":35-69",
            "content": "    randVar = truncnorm(a, b)\n    randomFunction = lambda: randVar.rvs(1)[0] * scale + loc\n    if evaluate:\n        return randomFunction()\n    return randomFunction\nfrom pykalman import KalmanFilter\nimport numpy as np\ndef checkMinMaxDict(value, minMaxDict, getMinMaxVal=False):\n    try:\n        assert [x for x in minMaxDict.keys() if x not in [\"min\", \"max\"]] == []\n    except:\n        print(\"PARAMETERS DUMP:\", value, minMaxDict, getMinMaxVal)\n        breakpoint()\n    try:\n        minVal = minMaxDict.get(\"min\", value)\n        maxVal = minMaxDict.get(\"max\", value)\n        if minVal != value and maxVal != value:\n            assert minVal < maxVal\n        flag = value <= maxVal and value >= minVal\n        if getMinMaxVal:\n            return flag, (minVal, maxVal)\n        else:\n            return flag\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"WTF IS GOING ON WITH CHECK_MIN_MAX_DICT\")\n        # breakpoint()\n        return False  # usually we have issue getting the number. it is not a number."
        },
        {
            "comment": "- superMean: calculates mean of a list, returns default value if list is empty\n- superMax: calculates maximum value of a list, returns default value if list is empty\n- superMin: calculates minimum value of a list, returns default value if list is empty\n- uniq: returns unique elements in the list, preserving order (if ordered=True) or not\n- get1DArrayEMA: applies exponential moving average to 1D array using given weights and window size\n- Kalman1D: performs Kalman smoothing on a time series data with damping factor",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":72-117",
            "content": "def superMean(mList: list, default=0):\n    if len(mList) == 0:\n        return default\n    return np.mean(mList)\ndef superMax(mList: list, default=0):\n    if len(mList) == 0:\n        return default\n    return max(mList)\ndef superMin(mList: list, default=0):\n    if len(mList) == 0:\n        return default\n    return min(mList)\ndef uniq(mList, ordered=True, random=False):\n    if ordered:\n        result = []\n        for elem in mList:\n            if elem not in result:\n                result.append(elem)\n    else:\n        result = list(set(mList))\n    if random:\n        import random\n        random.shuffle(result)\n    return result\ndef get1DArrayEMA(mArray, N=5):\n    weights = np.exp(np.linspace(0, 1, N))\n    weights = weights / np.sum(weights)\n    ema = np.convolve(weights, mArray, mode=\"valid\")\n    return ema\ndef Kalman1D(observations, damping=0.2):\n    # To return the smoothed time series data\n    observation_covariance = damping\n    initial_value_guess = observations[0]\n    transition_matrix = 1\n    transition_covariance = 0.1"
        },
        {
            "comment": "The code initializes a KalmanFilter object with given parameters and then uses it to perform smooth filtering on observations. Finally, it returns the predicted state. The other function converts a set of intervals (mSet) into a single uncertain interval using Sympy library.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":118-148",
            "content": "    # initial_value_guess # wtf is this shit?\n    kf = KalmanFilter(\n        initial_state_mean=initial_value_guess,\n        initial_state_covariance=observation_covariance,\n        observation_covariance=observation_covariance,\n        transition_covariance=transition_covariance,\n        transition_matrices=transition_matrix,\n    )\n    pred_state, state_cov = kf.smooth(observations)\n    return pred_state\ndef getContinualNonSympyMergeResult(inputMSetCandidates):\n    # basically the same example.\n    # assume no overlapping here.\n    import sympy\n    def unionToTupleList(myUnion):\n        unionBoundaries = list(myUnion.boundary)\n        unionBoundaries.sort()\n        leftBoundaries = unionBoundaries[::2]\n        rightBoundaries = unionBoundaries[1::2]\n        return list(zip(leftBoundaries, rightBoundaries))\n    def tupleSetToUncertain(mSet):\n        mUncertain = None\n        for start, end in mSet:\n            if mUncertain is None:\n                mUncertain = sympy.Interval(start, end)\n            else:\n                mUncertain += sympy.Interval(start, end)"
        },
        {
            "comment": "This code defines a function `mergeOverlappedInIntervalTupleList` that takes a list of interval tuples and merges any overlapping intervals. It then applies this function to each element in the `inputMSetCandidates` list, resulting in a unified set of merged intervals stored in `mSetUnified`. The left and right boundaries of these merged intervals are extracted into separate sets.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":149-174",
            "content": "        typeUncertain = type(mUncertain)\n        return mUncertain, typeUncertain\n    def mergeOverlappedInIntervalTupleList(intervalTupleList):\n        mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n        mUncertainBoundaryList = list(mUncertain.boundary)\n        mUncertainBoundaryList.sort()\n        mergedIntervalTupleList = list(\n            zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2])\n        )\n        return mergedIntervalTupleList\n    # mSet = mergeOverlappedInIntervalTupleList([(0, 1), (2, 3)])\n    # mSet2 = mergeOverlappedInIntervalTupleList([(0.5, 1.5), (1.6, 2.5)])\n    # print(\"MSET\", mSet)\n    # print(\"MSET2\", mSet2)\n    mSetCandidates = [\n        mergeOverlappedInIntervalTupleList(x) for x in inputMSetCandidates\n    ]\n    mSetUnified = [x for y in mSetCandidates for x in y]\n    leftBoundaryList = set([x[0] for x in mSetUnified])\n    rightBoundaryList = set([x[1] for x in mSetUnified])\n    # they may freaking overlap.\n    # if want nearby-merge strategy, simply just e"
        },
        {
            "comment": "Markers are assigned to intervals for enter and exit points.\nIterates through candidates' left and right boundaries, adding indices to their respective markers.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":174-194",
            "content": "xpand all intervals, merge them with union and shrink the individual intervals inside union respectively.\n    markers = {\n        \"enter\": {k: [] for k in leftBoundaryList},\n        \"exit\": {k: [] for k in rightBoundaryList},\n    }\n    for index, mSetCandidate in enumerate(mSetCandidates):\n        leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n        rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n        for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n            markers[\"enter\"][leftBoundaryOfCandidate].append(index)  # remap this thing!\n        for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n            markers[\"exit\"][rightBoundaryOfCandidate].append(index)  # remap this thing!\n    # now, iterate through the boundaries of mSetUnified.\n    unifiedBoundaryList = leftBoundaryList.union(\n        rightBoundaryList\n    )  # call me a set instead of a list please? now we must sort this thing\n    unifiedBoundaryList = list(unifiedBoundaryList)\n    unifiedBoundaryList.sort()"
        },
        {
            "comment": "This code processes a list of unified boundaries and their corresponding markers. It checks for empty ranges between boundaries, and adds them to the finalMappings dictionary if they are not the first boundary in the list.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":196-218",
            "content": "    unifiedBoundaryMarks = {}\n    finalMappings = {}\n    # print(\"MARKERS\", markers)\n    # breakpoint()\n    for index, boundary in enumerate(unifiedBoundaryList):\n        previousMark = unifiedBoundaryMarks.get(index - 1, [])\n        enterList = markers[\"enter\"].get(boundary, [])\n        exitList = markers[\"exit\"].get(boundary, [])\n        currentMark = set(previousMark + enterList).difference(set(exitList))\n        currentMark = list(currentMark)\n        unifiedBoundaryMarks.update({index: currentMark})\n        # now, handle the change? or not?\n        # let's just deal those empty ones, shall we?\n        if previousMark == []:  # inside it is empty range.\n            # elif currentMark == []:\n            if index == 0:\n                continue  # just the start, no need to note this down.\n            else:\n                finalMappings.update(\n                    {\n                        \"empty\": finalMappings.get(\"empty\", [])\n                        + [(unifiedBoundaryList[index - 1], boundary)]\n                    }"
        },
        {
            "comment": "Iterating through key mappings in the dictionary, sorting and updating finalMappings if they overlap.\nMerging overlapping intervals in a list of sub-interval tuples.\nReturning finalCats with merged and corrected intervals.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":219-247",
            "content": "                )\n            # the end of previous mark! this interval belongs to previousMark\n        else:\n            key = previousMark.copy()\n            key.sort()\n            key = tuple(key)\n            finalMappings.update(\n                {\n                    key: finalMappings.get(key, [])\n                    + [(unifiedBoundaryList[index - 1], boundary)]\n                }\n            )\n            # also the end of previous mark! belongs to previousMark.\n    ### NOW THE FINAL OUTPUT ###\n    finalCats = {}\n    for key, value in finalMappings.items():\n        # value is an array containing subInterval tuples.\n        value = mergeOverlappedInIntervalTupleList(value)\n        valueCorrected = [(mStart, mEnd) for mStart, mEnd in value if mStart < mEnd]\n        finalCats.update({key: valueCorrected})\n    # print(\"______________FINAL CATS______________\")\n    # print(finalCats)\n    return finalCats\ndef getContinualMappedNonSympyMergeResult(mRangesDict, concatSymbol=\"|\", noEmpty=True):\n    mKeyMaps = list(mRangesDict.keys())"
        },
        {
            "comment": "This function takes a dictionary of ranges, and merges overlapping ranges into larger continual ranges. It also handles empty sets if specified.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":248-278",
            "content": "    mSetCandidates = [mRangesDict[key] for key in mKeyMaps]\n    # the next step will automatically merge all overlapped candidates.\n    finalCats = getContinualNonSympyMergeResult(mSetCandidates)\n    finalCatsMapped = {\n        concatSymbol.join([mKeyMaps[k] for k in mTuple]): finalCats[mTuple]\n        for mTuple in finalCats.keys()\n        if type(mTuple) == tuple\n    }\n    if not noEmpty:\n        finalCatsMapped.update(\n            {k: finalCats[k] for k in finalCats.keys() if type(k) != tuple}\n        )\n    return finalCatsMapped\n    # default not to output empty set?\ndef getContinualMappedNonSympyMergeResultWithRangedEmpty(\n    mRangesDict, start, end, concatSymbol=\"|\"\n):\n    import uuid\n    emptySetName = str(uuid.uuid4())\n    newRangesDict = mRangesDict.copy()\n    newRangesDict.update({emptySetName: [(start, end)]})\n    newRangesDict = getContinualMappedNonSympyMergeResult(\n        newRangesDict, concatSymbol=\"|\", noEmpty=True\n    )\n    newRangesDict = {\n        key: [\n            (mStart, mEnd)\n            for mStart, mEnd in newRangesDict[key]"
        },
        {
            "comment": "The code is filtering and organizing a dictionary of time spans, likely for rendering purposes. It first removes any empty range values from the newRangesDict. Then it checks if each key contains a specific string format (mergedEmptySetName) and replaces that portion of the key with an updated name. If a key matches the emptySetName, it renames it to \"empty\". Finally, it updates the finalNewRangesDict with the modified keys and their corresponding values. This function is then called within the mergedRangesToSequential function, which appears to be sorting command time spans for rendering.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":279-306",
            "content": "            if mStart >= start and mEnd <= end and mStart < mEnd\n        ]\n        for key in newRangesDict.keys()\n    }\n    newRangesDict = {\n        key: newRangesDict[key]\n        for key in newRangesDict.keys()\n        if newRangesDict[key] != []\n    }\n    finalNewRangesDict = {}\n    for key in newRangesDict.keys():\n        mergedEmptySetName = \"{}{}\".format(concatSymbol, emptySetName)\n        if mergedEmptySetName in key:\n            newKey = key.replace(mergedEmptySetName, \"\")\n            finalNewRangesDict.update({newKey: newRangesDict[key]})\n        elif key == emptySetName:\n            finalNewRangesDict.update({\"empty\": newRangesDict[key]})\n        else:\n            finalNewRangesDict.update({key: newRangesDict[key]})\n    return finalNewRangesDict\ndef mergedRangesToSequential(renderDict):\n    renderList = []\n    for renderCommandString in renderDict.keys():\n        commandTimeSpans = renderDict[renderCommandString].copy()\n        # commandTimeSpan.sort(key=lambda x: x[0])\n        for commandTimeSpan in commandTimeSpans:"
        },
        {
            "comment": "This code contains functions for working with coordinates, time spans and Bezier curves. It includes a function to convert a sequential list of commands into merged ranges, another one to create Bezier curves with optional skewing, and some assertions for validating inputs.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":307-338",
            "content": "            mStart, mEnd = commandTimeSpan\n            if mStart < mEnd:\n                renderList.append([renderCommandString, commandTimeSpan].copy())\n    renderList.sort(key=lambda x: x[1][0])\n    return renderList\n    # for renderCommandString, commandTimeSpan in renderList:\n    #     print(renderCommandString, commandTimeSpan)\n    # so this is arranged as such:\n    # [(renderCommandString, commandTimeSpan), ...]\ndef sequentialToMergedRanges(sequence):\n    mergedRanges = {}\n    for commandString, commandTimeSpan in sequence:\n        mergedRanges.update(\n            {commandString: mergedRanges.get(commandString, []) + [commandTimeSpan]}\n        )\n    mergedRanges = getContinualMappedNonSympyMergeResult(mergedRanges)\n    return mergedRanges\nimport bezier\ndef bezierCurve(start=(0, 0), end=(1, 1), skew=0):\n    # skew: (-0.5,0.5) otherwise this shit will look ugly.\n    assert skew >= -0.5\n    assert skew <= 0.5\n    x_start, y_start = start\n    x_end, y_end = end\n    x_diff = x_end - x_start\n    y_diff = y_end - y_start"
        },
        {
            "comment": "This code defines a function called \"multiParameterExponentialNetwork\" that takes several arguments and uses a Bezier curve to evaluate an input value. It returns the y-coordinate of the evaluated point on the curve. The function uses predefined parameters for the curve's start, end, skew, and evaluation method.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":339-373",
            "content": "    nodes1 = np.asfortranarray(\n        [\n            [x_start, x_diff * (0.5 + skew), x_end],\n            [y_start, y_diff * (0.5 - skew), y_end],\n        ]\n    )\n    curve1 = bezier.Curve(nodes1, degree=2)\n    curve_params = {\"x_start\": x_start, \"x_diff\": x_diff, \"x_end\": x_end}\n    return curve1, curve_params\ndef evaluateBezierCurve(input_value: float, curve, curve_params: dict):\n    x_start = curve_params[\"x_start\"]\n    x_end = curve_params[\"x_end\"]\n    assert x_start <= input_value\n    assert x_end >= input_value\n    x_diff = curve_params[\"x_diff\"]\n    s = (input_value - x_start) / x_diff\n    points = curve.evaluate(s)\n    # we only get the single point.\n    point = points.T[0]\n    x, y = point\n    result = y\n    return result\ndef multiParameterExponentialNetwork(\n    *args,\n    input_bias=0.05,\n    curve_function=bezierCurve,\n    curve_function_kwargs={\"start\": (0, 0), \"end\": (1, 1), \"skew\": 0},\n    evaluate_function=evaluateBezierCurve\n):\n    curve, curve_params = curve_function(**curve_function_kwargs)\n    value = evaluate_function(input_bias, curve, curve_params)"
        },
        {
            "comment": "Code calculates the cursor of maximum average in a window for interpolated data. It supersamples the reference data, performs linear interpolation on supersampled data, calculates moving sum by convolving with ones array, and finds the index where the moving sum exceeds the window size to get the cursor of max average in the window.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":374-402",
            "content": "    for index, input_value in enumerate(args):\n        apply_list = [input_value] * (index + 1)\n        for apply_item in apply_list:\n            value += (1 - value) * evaluate_function(apply_item, curve, curve_params)\n    return value\ndef getCursorOfMaxAverageInWindow(\n    referenceData, windowSize, dataDuration, superSampleRate=8\n):\n    assert windowSize < dataDuration\n    # we supersample this reference data?\n    fp = referenceData\n    xp = np.linspace(0, dataDuration, len(fp))\n    interpolated_xp = np.linspace(0, dataDuration, len(fp) * superSampleRate)\n    fp = np.array(fp)\n    interpolated_fp = []\n    for x in interpolated_xp:\n        interpolated_value = np.interp(x, xp, fp)\n        interpolated_fp.append(interpolated_value)\n    interpolated_fp = np.array(interpolated_fp)\n    moving_sum_span = 0\n    for index, value in enumerate(interpolated_xp):\n        if value - windowSize >= 0:\n            break\n        moving_sum_span = index\n    moving_sum_span += 1\n    moving_sum = np.convolve(interpolated_fp, np.ones(moving_sum_span), \"valid\")"
        },
        {
            "comment": "Calculates index of maximum value in moving sum array. Clamps cursor to maximum possible value based on dataDuration and windowSize. Returns the clamped cursor as result.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/utils/mathlib.py\":403-406",
            "content": "    max_index = np.argmax(moving_sum)\n    cursor = interpolated_fp[max_index]\n    cursor = min(dataDuration - windowSize, cursor)\n    return cursor"
        }
    ]
}