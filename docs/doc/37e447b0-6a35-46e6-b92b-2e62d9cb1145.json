{
    "summary": "The code imports modules, fetches a proxy list, tests proxies' speeds and validates responses, sorts by delay, defines a function to test proxies and return results, and creates a context manager class for proxy config mode.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines a function \"getProxyList\" to fetch the proxy list from a specified URL (localhost) and retrieve proxy information in JSON format.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/network/proxy/clash.py\":0-31",
            "content": "# from faulthandler import disable\nfrom xmlrpc.client import MAXINT\nfrom lazero.network.asyncio import concurrentGet\nimport os\nimport json\nfrom typing import Literal, Union\n# from pprint import pprint\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\nlocalhost = \"http://127.0.0.1\"\nlocalhostWithPort = lambda port: \"{}:{}\".format(localhost, port)\nimport requests\n# so, how do you get the proxy list and test the speed for deepl.com?\n# if you really want to fall back, just change the proxy config.\ndef getProxyList(\n    port: int = 9911,\n    debug=False,\n    disallowed_types=[\"URLTest\", \"Reject\", \"Selector\", \"Direct\", \"Fallback\"],\n):  # default do not return proxy groups. only standalone proxies.\n    clashUrl = localhostWithPort(port) + \"/proxies\"  # this will reduce one layer of \"/\"\n    if debug:\n        print(clashUrl)\n    r = requests.get(clashUrl)\n    # return r.content\n    proxyInfo = r.json()\n    # pprint(proxyInfo)\n    proxyList = []\n    for proxyName, proxy in proxyInfo[\"proxies\"].items():\n        proxyType = proxy[\"type\"]"
        },
        {
            "comment": "This code defines a function `testProxyList` that tests the speed of a given URL using a list of proxies. It first generates a list of requests for each proxy in the given list and then uses `concurrentGet` to retrieve delay values for each proxy. If a valid delay is found, it adds the proxy's name to the `validProxyDelayList`.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/network/proxy/clash.py\":32-59",
            "content": "        # print(proxyType)\n        if proxyType not in disallowed_types:\n            proxyList.append(proxyName)\n    # proxyList = [key for key in proxyInfo[\"proxies\"].keys()]\n    return proxyList\ndef testProxyList(\n    proxyList,\n    port: int = 9911,\n    url=\"https://deepl.com\",\n    # debug=False,\n    timeout: int = 3000,  # in miliseconds?\n    valid=True,  # only return those with valid delay values.\n):  # test the speed for given url\n    # first, generate the proper list of requests.\n    params = {\"timeout\": timeout, \"url\": url}\n    url_list = [\n        localhostWithPort(port) + \"/proxies/{}/delay\".format(proxyName)\n        for proxyName in proxyList\n    ]\n    delayList = concurrentGet(url_list, processor=lambda x: x.json(), params=params)\n    validProxyDelayList = []\n    proxyDelayList = zip(delayList, proxyList)\n    for delayDict, proxyName in proxyDelayList:\n        info = {\"name\": proxyName}\n        if \"delay\" in delayDict.keys():  # we only get those with valid responses.\n            # delay = delayDict[\"delay\"]"
        },
        {
            "comment": "This code defines a function `setProxyWithSelector` which takes parameters for the proxy name, selector type (defaulting to \"GLOBAL\"), port number (defaulting to 9911), and a debug flag. It creates a URL for the specified selector and sends a PUT request with the proxy name as data. If the request returns status code 204, the function continues; otherwise, it prints an error message. The `validProxyDelayList` function sorts a list of dictionaries based on their \"delay\" key.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/network/proxy/clash.py\":60-89",
            "content": "            info.update(delayDict)\n            validProxyDelayList.append(info)\n        elif valid == False:\n            info.update({\"delay\": MAXINT})  # remove these first, please?\n            validProxyDelayList.append(info)\n    validProxyDelayList.sort(key=lambda x: x[\"delay\"])\n    return validProxyDelayList\ndef setProxyWithSelector(\n    proxyName, selector=\"GLOBAL\", port: int = 9911, debug=False\n):  # how to make sure it will use 'GLOBAL'? it needs to be done with the config.\n    if debug:\n        print(\"select proxy %s with selector %s\" % (proxyName, selector))\n    clashUrl = localhostWithPort(port) + \"/proxies/{}\".format(selector)\n    r = requests.put(\n        clashUrl, data=json.dumps({\"name\": proxyName}, ensure_ascii=False).encode()\n    )\n    try:\n        assert r.status_code == 204\n    except:\n        import traceback\n        traceback.print_exc()\n        try:\n            print(r.content)\n            print(\"error code:\", r.status_code)\n        except:\n            ...\n        print(\"error when setting proxy %s with selector %s\" % (proxyName, selector))"
        },
        {
            "comment": "92-105: Define function setProxyConfig with optional arguments for port, http_port and mode.\n\n106-108: URL for Clash config endpoint construction based on port number.\n\n109-124: Patch the Clash configuration with optional arguments.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/network/proxy/clash.py\":92-124",
            "content": "def setProxyConfig(\n    port: int = 9911,\n    http_port: Union[None, int] = None,\n    mode: Literal[\n        \"Global\", \"Rule\", \"Direct\", None\n    ] = None,  # currently this mode is configured as 'rule' so everything related to 'deepl' will be redirected.\n):\n    # https://clash.gitbook.io/doc/restful-api/config\n    # sure you can patch more things but that's enough for now.\n    clashUrl = localhostWithPort(port) + \"/configs\"\n    configs = {}\n    if http_port:\n        configs.update({\"port\": http_port})\n    if mode:\n        configs.update({\"mode\": mode})\n    r = requests.patch(clashUrl, data=json.dumps(configs, ensure_ascii=False).encode())\n    assert r.status_code == 204\ndef getConnectionGateway(\n    port: int = 9911,\n):  # get the clash local http proxy connection port.\n    clashUrl = localhostWithPort(port) + \"/configs\"\n    r = requests.get(clashUrl)\n    configs = r.json()\n    http_port = configs[\"port\"]\n    gateway = localhostWithPort(http_port)\n    return gateway\ndef getTestedProxyList(\n    port: int = 9911,\n    debug=False,"
        },
        {
            "comment": "This code defines a function that tests a list of proxies and returns valid ones with their delay times. It also creates a context manager class to manage the proxy config mode.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/network/proxy/clash.py\":125-157",
            "content": "    disallowed_types=[\"URLTest\", \"Reject\", \"Selector\", \"Direct\", \"Fallback\"],\n    url=\"https://deepl.com\",\n    timeout: int = 5000,  # in miliseconds?\n    valid=True,\n):\n    proxyList = getProxyList(debug=debug, port=port, disallowed_types=disallowed_types)\n    # pprint.pprint(result)\n    validProxyDelayList = testProxyList(\n        proxyList, timeout=timeout, url=url, valid=valid\n    )\n    return validProxyDelayList\nfrom contextlib import AbstractContextManager\nclass clashProxyStateManager(AbstractContextManager):\n    def __init__(\n        self,\n        enter: Literal[\"Global\", \"Rule\", \"Direct\", None],\n        exit: Literal[\"Global\", \"Rule\", \"Direct\", None],\n        port=9911,\n    ):\n        self.enter = enter\n        self.exit = exit\n        self.port = port\n    def __enter__(self):\n        setProxyConfig(port=self.port, mode=self.enter)\n    def __exit__(self, exctype, excinst, exctb):\n        setProxyConfig(port=self.port, mode=self.exit)\n        return"
        }
    ]
}