{
    "summary": "The code features a context manager for temporary directory changes, exception handling and formatting functions using autopep8 and black. It also includes decorators for pickling functions with debug mode, handles inputs, processes function arguments, extracts lines for execution, provides exception-handling functions for debugging and pause, an iterator for temporary directories, and a retry decorator with optional delay.",
    "details": [
        {
            "comment": "This code defines a context manager class called workingDirectoryManager that allows temporarily changing the current working directory. It initializes with an optional argument for the new working directory, and in the `__enter__` method, it checks if a new working directory is provided, changes the current working directory to the provided path (if available), and asserts that the new directory is an absolute path. In the `__exit__` method, it restores the original current working directory before exiting the context manager. The code also imports various modules and classes for different purposes such as handling file paths, creating temporary files, generating unique identifiers, and executing subprocesses.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":0-36",
            "content": "# print package name of this 'lazero.program.functools' package, please?\n# print('PATH', __path__)\n# print('NAME', __name__)\n# # lazero.program.functools\n# def someFunction():\n#     print('NAME', __name__)\n# lazero.program.functools\n# it is the same!\n# what about let's call it elsewhere?\n## reserved keyword: __pickled_arguments__\nfrom typing import Literal, Union\nimport argparse\nimport os\nimport pickle\nimport dill\nfrom contextlib import AbstractContextManager\nimport subprocess\nfrom lazero.filesystem.temp import tmpfile\nimport uuid\nclass workingDirectoryManager(AbstractContextManager):\n    def __init__(\n        self,\n        workingDirectory: Union[str, None],\n    ):\n        self.currentWorkingDirectory = os.path.abspath(os.curdir)\n        self.workingDirectory = workingDirectory\n    def __enter__(self):\n        if self.workingDirectory:\n            assert os.path.isabs(self.workingDirectory)\n            os.chdir(self.workingDirectory)\n    def __exit__(self, exctype, excinst, exctb):\n        if self.workingDirectory:\n            os.chdir(self.currentWorkingDirectory)"
        },
        {
            "comment": "Decorator for pickling package functions using dill or pickle, debug mode prints function names and package name.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":39-63",
            "content": "def pickledFunction(\n    packageName,\n    workingDirectory: Union[None, str] = None,\n    debug=False,\n    backend: Literal[\"dill\", \"pickle\"] = \"dill\",\n):\n    # this decorator is used inside a specific INSTALLED package like pyjom. if you want to use it for non-installed package, better set the working directory for this decorator.\n    backendMap = {\"dill\": dill, \"pickle\": pickle}\n    currentBackend = backendMap[backend]\n    if debug:\n        print(\"package name: %s\" % packageName)\n    def inner(func):\n        funcName = func.__name__\n        argumentFlag = \"--{}\".format(funcName)\n        if debug:\n            print(\"function name: %s\" % funcName)\n        if (\n            packageName == \"__main__\"\n        ):  # this will accept nothing as argument or keyword arguments\n            parser = argparse.ArgumentParser()\n            parser.add_argument(argumentFlag, type=str, default=\"\")\n            parsed_args = parser.parse_args()\n            picklePath = parsed_args.__dict__[funcName]\n            if picklePath == \"\":"
        },
        {
            "comment": "Checks if the pickle file with the function arguments exists, loads the arguments and returns the function result. If not found, raises an exception with a message indicating the nonexistent pickle path. If no working directory is provided, defines a wrapper function to store the function arguments in a pickle file for later use.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":64-86",
            "content": "                ...\n            elif os.path.exists(picklePath):\n                with open(picklePath, \"rb\") as f:\n                    pickledArguments = currentBackend.load(f)\n                args = pickledArguments[\"args\"]\n                kwargs = pickledArguments[\"kwargs\"]\n                if debug:\n                    print(\"function args: %s\" % args)\n                    print(\"function kwargs: %s\" % kwargs)\n                result = func(*args, **kwargs)\n                with open(picklePath, \"wb\") as f:\n                    currentBackend.dump(result, f)\n                if debug:\n                    print(\"function result: %s\" % result)\n            else:\n                raise Exception(\"nonexistant pickle path:\", picklePath.__repr__())\n        else:\n            # if workingDirectory:\n            def wrapper(*args, **kwargs):\n                pickledArguments = {}\n                pickledArguments[\"args\"] = args\n                pickledArguments[\"kwargs\"] = kwargs\n                # you need to get current working directory first."
        },
        {
            "comment": "Creating a temporary file, picking arguments to function and dumping them, changing working directory.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":87-106",
            "content": "                # also you need a context manager to deal with problems, being able to get back to current working directory no matter what.\n                pickleFileName = \"{}.{}\".format(\n                    str(uuid.uuid4()).replace(\"-\", \"_\"), backend\n                )\n                pickleFilePath = os.path.join(\n                    \"/dev/shm/pickledFunctionParameters\", pickleFileName\n                )\n                with tmpfile(pickleFilePath):\n                    with open(pickleFilePath, \"wb\") as f:\n                        currentBackend.dump(pickledArguments, f)\n                        if debug:\n                            print(\"arguments dumped to %s\" % pickleFilePath)\n                    with workingDirectoryManager(\n                        workingDirectory\n                    ):  # this parameter could be None.\n                        commandArguments = [\n                            \"python3\",\n                            \"-m\",\n                            packageName,\n                            argumentFlag,"
        },
        {
            "comment": "This code defines a function called \"skipException\" that takes in various parameters like debug_flag, breakpoint_flag, delayAfterException, defaultReturn, global_variables, and local_variables. It then returns a wrapper function that can be used to execute another function while handling exceptions. The wrapper function updates the global and local variable dictionaries with the provided values before executing the target function.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":107-141",
            "content": "                            pickleFilePath,\n                        ]\n                        result = subprocess.run(\n                            commandArguments,\n                            shell=False,\n                        )\n                        assert result.returncode == 0\n                        if debug:\n                            print(\"subprocess execution done\")\n                    with open(pickleFilePath, \"rb\") as f:\n                        return currentBackend.load(f)\n            return wrapper\n        return lambda: None  # a symbolic function.\n    return inner\n# import dill\nfrom contextlib import suppress\nimport traceback\ndef skipException(\n    debug_flag=False,\n    breakpoint_flag=False,\n    delayAfterException: int = 3,\n    defaultReturn=None,\n    global_variables: dict = {},\n    local_variables: dict = {},\n):\n    def wrapper(func):\n        globals().update(global_variables)\n        locals().update(local_variables)\n        # myExec = lambda command, myGlobals, myLocals: exec(command) # new way of merging dicts in python 3.9, more 'functional'?"
        },
        {
            "comment": "Code contains several functions for handling lines and code blocks. It includes a space counter function, a remove extra return function, an empty line checker, and a code block getter.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":142-174",
            "content": "        def space_counter(line):\n            counter = 0\n            for x in line:\n                if x == \" \":\n                    counter += 1\n                else:\n                    break\n            return counter\n        def remove_extra_return(code):\n            while True:\n                if \"\\n\\n\" in code:\n                    code = code.replace(\"\\n\\n\", \"\\n\")\n                else:\n                    break\n            return code\n        def isEmptyLine(line):\n            emptyChars = [\"\\n\", \"\\t\", \"\\r\", \" \"]\n            length = len(line)\n            emptyCounts = 0\n            for char in line:\n                if char in emptyChars:\n                    emptyCounts += 1\n            return emptyCounts == length\n        def getCodeBlocks(lines):\n            mBlocks = []\n            current_block = lines[0]\n            lines = lines + [\"\"]\n            keywords = [\" \", \"def \", \"async \", \"with \", \"class \", \"@\"]\n            # keywords = [\" \", \"def\", \"async def\", \"with\", \"async with\",\"class\", \"@\"]\n            for line in lines[1:]:"
        },
        {
            "comment": "This code defines functions to format Python code using \"autopep8\" and \"black\". It first splits the input code into lines, removes extra returns, and then uses these formatting tools to reformat the code while setting a maximum line length. The code also accepts optional arguments for debugging and setting the maximum line length.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":175-201",
            "content": "                if sum([line.startswith(keyword) for keyword in keywords]):\n                    current_block += \"\\n\"\n                    current_block += line\n                else:\n                    mBlocks.append(current_block)\n                    current_block = line\n            return mBlocks\n        def getExtendedLines(splited_code):\n            splited_code = [x.rstrip() for x in splited_code]\n            splited_code = \"\\n\".join(splited_code).replace(\"\\\\\\n\", \"\")\n            splited_code = remove_extra_return(splited_code)\n            splited_code = splited_code.split(\"\\n\")\n            return splited_code\n        def reformatCode(func_code, MAXINT=10000000000, debug=False):\n            # with open(\"test.py\", \"r\") as f:\n            code = func_code\n            # need binary data.\n            code_encoded = code.encode(\"utf-8\")\n            import subprocess\n            command = (\n                \"autopep8 --max-line-length {MAXINT} - | black -l {MAXINT} -C -\".format(\n                    MAXINT=MAXINT"
        },
        {
            "comment": "This code is running a subprocess to execute a command, then checking the return code. If successful (return code 0), it retrieves the formatted output from the command execution and returns it. If there's an error or debug mode is on, it handles exceptions by printing the standard output and standard error streams along with a stack trace. If the function code needs reformatting, it uses a specific function to reformat the code before returning it. Additionally, this code defines a new_func that retrieves the original function's name and source code, reformats it if necessary, and returns it.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":202-229",
            "content": "                )\n            )\n            commandLine = [\"bash\", \"-c\", command]\n            result = subprocess.run(\n                commandLine, input=code_encoded, capture_output=True\n            )\n            try:\n                assert result.returncode == 0\n                code_formatted = result.stdout.decode(\"utf-8\")\n            except:\n                if debug:\n                    import traceback\n                    traceback.print_exc()\n                    print(\"STDOUT\", result.stdout)\n                    print(\"STDERR\", result.stderr)\n                code_formatted = code\n            if debug:\n                print(code_formatted)\n            return code_formatted\n        def new_func(*args, **kwargs):\n            func_name = func.__name__\n            func_code = dill.source.getsource(func)\n            # reformat the func code via our dearly autopep8-black formatter.\n            func_code = reformatCode(func_code, debug=debug_flag)\n            if debug_flag:\n                print(\"########## FUNCTION CODE #########\")"
        },
        {
            "comment": "This code is responsible for handling the case where a function is decorated with @skipException decorator, preventing any recursive calls within the same context. It checks if the first line of the function's code starts with \"@skipException\", and if not, raises an exception indicating improper nesting of the decorator. The code then extracts the function definition, strips off the decorator and function name, and stores the remaining arguments in a variable for further processing. If debugging is enabled, it prints out the function's arguments.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":230-251",
            "content": "                print(\n                    func_code\n                )  # do not use chained decorator since doing so will definitely fail everything?\n                print(\"########## FUNCTION CODE #########\")\n                print(\"########## FUNCTION #########\")\n            # print(func_code)\n            func_code = remove_extra_return(func_code)\n            splited_code = func_code.split(\"\\n\")\n            splited_code = getExtendedLines(splited_code)\n            # index 0: decorator\n            # index 1: function name\n            # no recursion support. may work inside another undecorated function.\n            try:\n                assert splited_code[0].strip().startswith(\"@skipException\")\n            except:\n                raise Exception(\"Do not nesting the use of @skipException decorator\")\n            function_definition = splited_code[1]\n            function_args = function_definition[:-1].replace(\n                \"def {}\".format(func_name), \"\"\n            )\n            if debug_flag:\n                print(\"FUNCTION ARGS:\", function_args)"
        },
        {
            "comment": "The code is parsing the function arguments and splitting them into positional and keyword arguments. It then updates a dictionary with default values for the keyword arguments if they are present in the function call. This allows the function to handle cases where the user provides default values or additional keyword arguments beyond what the function expects.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":252-272",
            "content": "            kwdefaults = func.__defaults__\n            pass_kwargs = {}\n            if \"=\" in function_args:\n                assert kwdefaults != None\n                arg_remains = function_args.split(\"=\")[0]\n                kwarg_remains = function_args.replace(arg_remains, \"\")\n                kwarg_extra_names = [\n                    content.split(\",\")[-1].strip()\n                    for index, content in enumerate(kwarg_remains.split(\"=\"))\n                    if index % 2 == 1\n                ]\n                mfunctionArgsPrimitive = arg_remains.replace(\"(\", \"\").split(\",\")\n                kwarg_names = [mfunctionArgsPrimitive[-1].strip()] + kwarg_extra_names\n                mfunctionArgs = mfunctionArgsPrimitive[:-1]\n                if debug_flag:\n                    print(\"PASSED KEYWORD ARGS:\", kwargs)\n                    print(\"KWARG NAMES:\", kwarg_names)\n                for key, value in zip(kwarg_names, kwdefaults):\n                    pass_kwargs.update({key: value})\n                for key in kwargs.keys():"
        },
        {
            "comment": "Checking and setting positional arguments from input string, and preparing code for execution.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":273-294",
            "content": "                    assert key in kwarg_names\n                    pass_kwargs[key] = kwargs[key]\n            else:\n                assert kwdefaults == None\n                mfunctionArgs = (\n                    function_args.replace(\"(\", \"\").replace(\")\", \"\").split(\",\")\n                )\n            mfunctionArgs = [x.strip() for x in mfunctionArgs]\n            mfunctionArgs = [x for x in mfunctionArgs if not isEmptyLine(x)]\n            if debug_flag:\n                print(\"POSITIONAL ARGS:\", mfunctionArgs)\n            assert len(args) == len(mfunctionArgs)\n            for key, value in zip(mfunctionArgs, args):\n                exec(\"{} = {}\".format(key, value))\n            if kwdefaults is not None:\n                for key, value in pass_kwargs.items():\n                    exec(\"{} = {}\".format(key, value))\n            actualCode = splited_code[2:]\n            actualCode = [x for x in actualCode if not isEmptyLine(x)]\n            minIndent = min([space_counter(line) for line in actualCode])\n            # split the code into different sections."
        },
        {
            "comment": "This code extracts and processes lines from the actual code, then iterates through the extracted blocks. If a block starts with \"return\", it assigns the return value to a temporary variable, executes it, and returns the value. If debug_flag is on, it prints a separator before printing each code block. If debug_flag is off but a block raises an exception, it suppresses it.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":295-318",
            "content": "            if debug_flag:\n                print(minIndent)\n            newLines = [line[minIndent:] for line in actualCode]\n            codeBlocks = getCodeBlocks(newLines)\n            for block in codeBlocks:\n                no_exception = False\n                if debug_flag:\n                    print(\"##########CODEBLOCK##########\")\n                    print(block)\n                    print(\"##########CODEBLOCK##########\")\n                if block.startswith(\"return \"):\n                    returnName = \"var_\" + str(uuid.uuid4()).replace(\"-\", \"_\")\n                    block = \"{} = {}\".format(returnName, block[len(\"return \") :])\n                    exec(block)\n                    value = locals().get(returnName)\n                    return value\n                elif block == \"return\":\n                    return\n                elif not debug_flag:\n                    with suppress(Exception):\n                        exec(block)\n                        no_exception = True\n                else:\n                    try:"
        },
        {
            "comment": "This code defines functions that wrap another function, handling exceptions and allowing for debugging or breakpoint pausing. The wrapped function is executed within a try-except block to catch any exceptions. If an exception occurs, it prints the traceback (if a breakpoint flag is set) or simply waits with a delay (if a delayAfterException value is specified). Additionally, if a debug flag is set, it prints the function name and arguments before executing. The code also imports some functions and classes from other modules.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":319-354",
            "content": "                        exec(block)  # return outside of function?\n                        no_exception = True\n                    except:\n                        traceback.print_exc()\n                        if breakpoint_flag:\n                            breakpoint()\n                if not no_exception:\n                    print(\"##########DELAY AFTER EXCEPTION##########\")\n                    import time\n                    time.sleep(delayAfterException)\n                    print(\"##########DELAY AFTER EXCEPTION##########\")\n            if debug_flag:\n                print(\"########## FUNCTION #########\")\n            return defaultReturn\n        return new_func\n    return wrapper\ndef skipExceptionVerbose(func):\n    return skipException(debug_flag=True)(func)\ndef skipExceptionBreakpoint(func):\n    return skipException(breakpoint_flag=True)(func)\ndef skipExceptionDebug(func):\n    return skipException(breakpoint_flag=True, debug_flag=True)(func)\n# breakpoint()\nfrom lazero.filesystem.temp import tmpdir\nfrom typing import Union"
        },
        {
            "comment": "This code defines a function `iterateWithTempDirectory` which takes a temporary directory path and returns an iterator function. If no tempdir is provided, it returns a context manager that does nothing (nullcontext). If a tempdir is provided, it returns a context manager that creates a temporary directory using the `tmpdir` function from the `pytest_timeout` module. The outer function wraps another function and returns an iterator that yields the results of calling the wrapped function on each element of a generator-like object. If the optional `iterate` parameter is set to False, it skips iteration over the generator-like object.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":355-382",
            "content": "from contextlib import nullcontext\nfrom types import GeneratorType\n# generators create generators. that's it.\ndef iterateWithTempDirectory(\n    tempdir: Union[str, None] = None, targetType=GeneratorType\n):\n    # iterate is some added keyword.\n    if tempdir is None:\n        contextManager = lambda: nullcontext()\n    else:\n        contextManager = lambda: tmpdir(tempdir)\n    def inner(func):\n        def wrapper(  # default to be auto. otherwise why you use this?\n            generatorMaybe, iterate: Literal[False, True, \"auto\"] = \"auto\", **kwargs\n        ):  # this wrapper will void function input signatures maybe? anyway let's do it!\n            if iterate == \"auto\":\n                iterate = type(generatorMaybe) == targetType\n            def iterator(generatorMaybe, **kwargs):\n                for elem in generatorMaybe:\n                    with contextManager():\n                        yield func(elem, **kwargs)\n            if iterate:\n                return iterator(generatorMaybe, **kwargs)\n            else:"
        },
        {
            "comment": "Function decorator that retries a function multiple times in case of an exception, with optional delay between retries and print statements for debugging.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/program/functools.py\":383-419",
            "content": "                with contextManager():\n                    return func(generatorMaybe, **kwargs)\n        return wrapper\n    return inner\nimport time\ndef suppressException(\n    showException=True,\n    defaultReturn=None,\n    tries: int = 1,\n    delay: float = 3,\n    debug: bool = True,\n):\n    if tries < 1:\n        tries = 1\n    def inner(func):\n        def wrapper(*args, **kwargs):\n            for index in range(tries):\n                if debug:\n                    print(\"try times: %d\" % index)\n                try:\n                    return func(*args, **kwargs)\n                except:\n                    if showException:\n                        traceback.print_exc()\n                    time.sleep(delay)\n            return defaultReturn\n        return wrapper\n    return inner"
        }
    ]
}