{
    "summary": "The code updates a data dictionary, searches for specific terms in index directories, retrieves and merges relevant data, calculates line scores, ranks files, and prepares for rendering.",
    "details": [
        {
            "comment": "Updates data dictionary with line index, normalized score and divisor from the JSON-based database.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":0-26",
            "content": "import os\nfrom lazero.search.api import lazeroCachePath\nfrom lazero.search.index import retrieveFilePathFromLineIndex\ndef updateDataDictWithLineIndexNormalizedScoreAndDivisor(\n    dataDict,\n    index,\n    normalized_score,\n    divisor,\n    tinydbDatabasePath=os.path.join(lazeroCachePath, \"index.json\"),\n):\n    # this thing shall be stored in \"the json based database\".\n    line_index_original, line_remainer = divmod(\n        index, divisor\n    )  # with or without original line?\n    # content = getValueByKeyFromDatabase(str(line_index)+\"_content\")\n    # it is just demonstration.\n    filepath = retrieveFilePathFromLineIndex(index, databasePath=tinydbDatabasePath)\n    filepathDataDict = dataDict.get(filepath, {})\n    filepathLineIndexOriginalDataDict = filepathDataDict.get(line_index_original, {})\n    filepathLineIndexOriginalDataDictLineRemainerScoreList = (\n        filepathLineIndexOriginalDataDict.get(line_remainer, [])\n    )  # shall you use the best score or the average score?\n    filepathLineIndexOriginalDataDictLineRemainerScoreList.append(normalized_score)"
        },
        {
            "comment": "This code imports the necessary functions and classes for search functionality from \"lazero.search.txtai.search\" and \"lazero.search.whoosh.search\". It then defines a function called \"search\" that takes in parameters such as query, index directories, limit, tinydbDatabasePath, and filter_filepath. The function returns the results of the search based on the specified parameters.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":28-60",
            "content": "    filepathLineIndexOriginalDataDict.update(\n        {line_remainer: filepathLineIndexOriginalDataDictLineRemainerScoreList}\n    )\n    filepathDataDict.update({line_index_original: filepathLineIndexOriginalDataDict})\n    dataDict.update({filepath: filepathDataDict})\n    return dataDict\n# so you have both search methods in whoosh and txtai.\n# first get the config, the 'withOriginalLine' from tinydb\nfrom lazero.search.txtai.search import txtaiSearch\nfrom lazero.search.whoosh.search import whooshSearch\nfrom lazero.search.index import retrieveConfig\n# import statistics\ndef weightedMean(data, epsilon=1e-3):\n    weightTotal = sum(data) + epsilon\n    mean = sum([value**2 for value in data]) / weightTotal\n    return mean\ndef search(\n    query,\n    indexDirectories={\n        \"txtai\": os.path.join(lazeroCachePath, \"txtai_index\"),\n        \"whoosh\": os.path.join(lazeroCachePath, \"whoosh_index\"),\n    },\n    limit=100,\n    tinydbDatabasePath=os.path.join(lazeroCachePath, \"index.json\"),\n    filter_filepath=None,\n    methods={"
        },
        {
            "comment": "This code checks if the index directories contain \"txtai\" and \"whoosh\". If \"txtai\" is present, it calls txtaiSearch function. If \"whoosh\" is present, it calls whooshSearch function. Both functions return data to 'dataDict' using query, filter_filepath, limit, withOriginalLine, and tinydbDatabasePath as parameters.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":61-86",
            "content": "        \"subLineScore\": weightedMean,  # statistics.mean\n        \"lineScore\": max,\n        \"fileScore\": max,\n    },\n):  # so we use 'indexDirectories' alone to determine the backends.\n    assert indexDirectories != {}  # not using empty index here.\n    dataDict = {}\n    withOriginalLine = retrieveConfig(\"withOriginalLine\")  # retrieve this from tinydb.\n    if \"txtai\" in indexDirectories.keys():\n        dataDict = txtaiSearch(\n            query,\n            indexDirectories[\"txtai\"],\n            filter_filepath=filter_filepath,\n            limit=limit,\n            withOriginalLine=withOriginalLine,\n            tinydbDatabasePath=tinydbDatabasePath,\n            dataDict=dataDict,\n        )\n    if \"whoosh\" in indexDirectories.keys():\n        dataDict = whooshSearch(  # so we hide some parameters for whoosh.\n            query,\n            indexDirectories[\"whoosh\"],\n            filter_filepath=filter_filepath,\n            limit=limit,\n            withOriginalLine=withOriginalLine,\n            tinydbDatabasePath=tinydbDatabasePath,"
        },
        {
            "comment": "This code retrieves \u7c97\u6392 and \u7cbe\u6392 data from a given dataDict. The structure of the dataDict is filepath -> {} -> line_index_original -> {} -> line_remainder -> []. It merges lines if needed, shows no more than three related lines per file, and ensures that lines can be jumped to if necessary.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":87-108",
            "content": "            dataDict=dataDict,\n        )\n    # the hard part. we need to retrieve \u7c97\u6392 \u7cbe\u6392 data here.\n    # what is the structure of the dataDict?\n    # {} -> filepath -> {} -> line_index_original -> {} -> line_remainder -> [] (the score of this single line.)\n    # you also need to merge lines if you have to.\n    # for every file, show no more than three related lines.\n    # but you need to ensure that you can jump to them, just in case.\n    # no need to merge lines if they overlap.\n    fileRankList = []\n    lineRankListInFileAsDict = {}\n    lineRankListInAllFiles = []\n    for filepath, linesDict in dataDict.items():\n        lineScores = []\n        for line_index_original, subLinesDict in linesDict.items():\n            subLineScores = []\n            for line_remainer, scoreList in subLinesDict.items():\n                subLineScore = methods[\"subLineScore\"](scoreList)\n                subLineScores.append(subLineScore)\n            lineScore = methods[\"lineScore\"](subLineScores)\n            lineScores.append(lineScore)"
        },
        {
            "comment": "Code is computing and storing line scores for each file. It updates a dictionary with the scores, then sorts them to obtain file and line ranks in descending order based on their scores. Finally, it returns three lists: file rank list, line rank list by file, and line rank list for all files.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":109-132",
            "content": "            lineScoreWithOriginalIndex = {\n                \"line_index_original\": line_index_original,\n                \"score\": lineScore,\n            }\n            lineScreWithOriginalIndexAndFilePath = {\"filepath\": filepath}\n            lineScreWithOriginalIndexAndFilePath.update(lineScoreWithOriginalIndex)\n            lineRankListInFileAsDict.update(\n                {\n                    filepath: lineRankListInFileAsDict.get(filepath, [])\n                    + [lineScoreWithOriginalIndex]\n                }\n            )\n            lineRankListInAllFiles.append(lineScreWithOriginalIndexAndFilePath)\n        # \u7cbe\u6392\n        lineRankListInFileAsDict[filepath].sort(key=lambda x: -x[\"score\"])\n        fileScore = methods[\"fileScore\"](lineScores)\n        fileRankList.append({\"filepath\": filepath, \"score\": fileScore})\n    # \u7c97\u6392\n    fileRankList.sort(key=lambda x: -x[\"score\"])\n    lineRankListInAllFiles.sort(key=lambda x: -x[\"score\"])\n    return (\n        fileRankList,\n        lineRankListInFileAsDict,\n        lineRankListInAllFiles,  # maybe you need this shit?"
        },
        {
            "comment": "These comments are asking if the code is ready to render, if displaying the score is desired on the panel title, and if it's ready for rendering.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/search.py\":133-136",
            "content": "    )\n    # ready to render this shit?\n    # you want to display score or not?\n    # as the title on panel?"
        }
    ]
}