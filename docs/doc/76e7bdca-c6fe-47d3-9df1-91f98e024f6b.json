{
    "summary": "The code imports modules for querying a TinyDB database, initializes Query object and TinyDB instance with a specific path, includes functions for retrieving file paths, line ranges, configuration values, indexing files in a directory, creating a temporary index mapping, combines line ranges and original content for each group, removes duplicates, stores the result in the database, and iterates over changed lines, yielding them with or without file path based on condition.",
    "details": [
        {
            "comment": "Imports necessary modules and functions for querying the tinydb database using line index. \nCreates a cached function `tinydbQueryBootstrap` to initialize Query object and TinyDB instance with a specific database path.\nRetrieves file path based on given line index from the initialized TinyDB database.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":0-34",
            "content": "import os\nfrom lazero.search.api import (\n    lazeroCachePath,\n    listFilesInDirectory,\n    storeKeyValuePairsToDatabase,\n)\nfrom lazero.search.preprocessing import (\n    getLineWiseAndListOfCleanedMergedConvGroupWithLineIndexMappingFromStringReadFromFile,\n    getFourVersionOfLineInListOfCleanedMergedConvGroupWithLineIndexMapping,\n)\nimport tinydb\nimport json\nfrom tinydb import Query\nfrom functools import lru_cache\n@lru_cache(maxsize=1)\ndef tinydbQueryBootstrap(databasePath=os.path.join(lazeroCachePath, \"index.json\")):\n    User = Query()\n    if not os.path.exists(databasePath):\n        raise Exception(\"Could not find tinydb database path:\", databasePath)\n    database = tinydb.TinyDB(databasePath)\n    return User, database\ndef retrieveFilePathFromLineIndex(\n    line_index, databasePath=os.path.join(lazeroCachePath, \"index.json\")\n):\n    # line index need not to be normalized.\n    User, database = tinydbQueryBootstrap(databasePath)\n    results = database.search((User.start <= line_index) & (User.end >= line_index))\n    path = results[0][\"path\"]"
        },
        {
            "comment": "Line 35-74 of \"lazero/lazero/search/index.py\" contains functions for indexing and retrieving file paths, line ranges, and configuration values from a database.\n\n- retrieveLineRangeFromFilePath: returns the start and end (inclusive) lines of a given filepath from the database\n- retrieveConfig: returns the value of a specific configuration name from the database\n- checkEndsWithinAllowedExtensions: checks if a filepath ends with any of the allowed extensions and returns True/False\n- indexFilesInDirectory: recursively indexes files in a directory, updating or creating entries in the database based on the provided parameters",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":35-74",
            "content": "    return path\ndef retrieveLineRangeFromFilePath(\n    filepath, databasePath=os.path.join(lazeroCachePath, \"index.json\")\n):\n    # line index need not to be normalized.\n    User, database = tinydbQueryBootstrap(databasePath)\n    results = database.search((User.path == filepath))\n    data = results[0]\n    start, end = data[\"start\"], data[\"end\"]\n    return start, end  # inclusive.\ndef retrieveConfig(name, databasePath=os.path.join(lazeroCachePath, \"index.json\")):\n    User, database = tinydbQueryBootstrap(databasePath)\n    results = database.search((User.name == name))\n    data = results[0]\n    value = data[\"value\"]\n    return value\nimport progressbar\ndef checkEndsWithinAllowedExtensions(filepath, allowedExtensions: list):\n    for ext in allowedExtensions:\n        if filepath.endswith(ext):\n            return True\n    return False\ndef indexFilesInDirectory(\n    directory,\n    databasePath=os.path.join(lazeroCachePath, \"index.json\"),\n    removeExists=True,\n    withFileName=False,\n    withOriginalLine=True,\n    allowedExtensions=[\".md\", \".txt\", \".html\"],"
        },
        {
            "comment": "Code comments:\n1. Atomically remove existing path and create a new database if it exists and removeExists is True.\n2. Insert \"name\" and \"value\" into the created database.\n3. Iterate through files in directory, excluding .git and checking allowed extensions.\n4. Read file data and handle any exceptions (e.g., PNG in path).",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":75-102",
            "content": "):\n    # we make this process atomic. if the path exists then we will remove it.\n    if os.path.exists(databasePath) and removeExists:\n        os.remove(databasePath)\n    database = tinydb.TinyDB(databasePath)\n    database.insert({\"name\": \"withOriginalLine\", \"value\": withOriginalLine})\n    counter = 0\n    divisor = 4 + int(withOriginalLine)\n    # you need to ignore .git directory.\n    for absoluteFilePath in progressbar.progressbar(\n        [\n            x\n            for x in listFilesInDirectory(directory)\n            if \"/.git/\" not in x\n            and checkEndsWithinAllowedExtensions(x, allowedExtensions)\n        ]\n    ):\n        temp_processed_line_index_mapping = []\n        try:\n            with open(absoluteFilePath, \"r\", encoding=\"utf8\") as f:\n                data = f.read()\n        except:\n            # there's PNG in the path.\n            continue\n        (\n            linewise,\n            listOfCleanedMergedConvGroupWithLineIndexMapping,\n        ) = getLineWiseAndListOfCleanedMergedConvGroupWithLineIndexMappingFromStringReadFromFile("
        },
        {
            "comment": "Storing file path, start and end indices in the database for each group of lines with the same conversation id.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":103-125",
            "content": "            data\n        )\n        total_length = (\n            len(listOfCleanedMergedConvGroupWithLineIndexMapping) * divisor\n        )  # because we use the original line.\n        # total_length = len(linewise) * divisor # because we use the original line.\n        # total_length = len(linewise) * divisor # because we use the original line.\n        # index >= start and index <= end\n        start = counter\n        end = counter + total_length - 1\n        counter += total_length\n        database.insert({\"path\": absoluteFilePath, \"start\": start, \"end\": end})\n        # shall we change the end index into something inclusive? you need to minus one.\n        # print(len(listOfCleanedMergedConvGroupWithLineIndexMapping))\n        # 1421 vs 13235: 9.31\n        # print('total_length:',total_length)\n        # breakpoint()\n        for index in range(total_length):\n            if index % divisor != 0:\n                continue\n            line_range = listOfCleanedMergedConvGroupWithLineIndexMapping[\n                index // divisor"
        },
        {
            "comment": "This code creates a temporary processed line index mapping, combines line ranges and original conv_group content for each group, removes duplicates, then stores the result in the database. It also retrieves changed lines from the list of cleaned merged conv groups with line index mappings.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":126-149",
            "content": "            ][\"line_range\"]\n            mIndex = start + index\n            temp_processed_line_index_mapping.append(\n                (str(mIndex // divisor), json.dumps(line_range))\n            )\n            # mIndex2 = start/divisor + index\n            temp_processed_line_index_mapping.append(  # here's how we store the original conv_group content\n                (\n                    str(mIndex // divisor) + \"_content\",\n                    listOfCleanedMergedConvGroupWithLineIndexMapping[index // divisor][\n                        \"conv_group_merged\"\n                    ],\n                )\n            )\n        temp_processed_line_index_mapping = list(set(temp_processed_line_index_mapping))\n        storeKeyValuePairsToDatabase(temp_processed_line_index_mapping)\n        for (\n            changed_lines\n        ) in getFourVersionOfLineInListOfCleanedMergedConvGroupWithLineIndexMapping(\n            listOfCleanedMergedConvGroupWithLineIndexMapping,\n            withOriginalLine=withOriginalLine,\n        ):\n            # you may yield them one by one."
        },
        {
            "comment": "Iterating over changed lines, yielding each line with or without file path depending on condition.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/index.py\":150-154",
            "content": "            for changed_line in changed_lines:\n                if withFileName:\n                    yield changed_line, absoluteFilePath\n                else:\n                    yield changed_line"
        }
    ]
}