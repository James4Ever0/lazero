{
    "summary": "The code performs text search using TxtAI index, allowing filtering by file path and result limits. It uses the txtaiSearch method, considering the withOriginalLine divisor for scoring search results. Additionally, it iterates over search queries, updating the data dictionary with index, normalized score, and divisor.",
    "details": [
        {
            "comment": "Code performs text search using TxtAI index.\n- Loads TxtAI index directory and checks if it exists.\n- Performs a single text search with optional filter by file path.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/txtai/search.py\":0-30",
            "content": "from lazero.search.txtai.model import embeddings\nfrom functools import lru_cache\nimport os\nfrom ..index import retrieveLineRangeFromFilePath\nfrom ...utils.mathlib import checkMinMaxDict\n@lru_cache(maxsize=1)\ndef txtaiSearchBootstrap(indexDirectory):\n    assert os.path.exists(indexDirectory)\n    assert os.path.isabs(indexDirectory)\n    embeddings.load(indexDirectory)\n    print(\"Loaded txtaiSearchBootstrap index directory: \" + indexDirectory)\ndef txtaiSearchSingle(\n    search_query_processed,\n    indexDirectory,\n    limit=100,\n    filter_filepath=None,  # to search for specific file only.\n    # does this freaking filter work?\n):  # why don't you have filter path related to the specific file damn?\n    # maybe you can do it later on. fuck.\n    txtaiSearchBootstrap(indexDirectory)\n    uid_list_tops = embeddings.search(search_query_processed, limit)\n    if filter_filepath:\n        start, end = retrieveLineRangeFromFilePath(filter_filepath)\n        lineRangeFilter = {\"min\": start, \"max\": end}\n    for index, score in uid_list_tops:"
        },
        {
            "comment": "This function performs a search using the txtaiSearch method. It takes a query, indexDirectory, filter_filepath (optional), limit (default 100), withOriginalLine (default True), and tinydbDatabasePath as parameters. It uses divisor based on withOriginalLine to calculate scores for search results.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/txtai/search.py\":31-62",
            "content": "        # uid = int(uid)\n        # where is the damn score? wtf?\n        if filter_filepath:\n            result = checkMinMaxDict(index, lineRangeFilter)\n            if not result:\n                continue  # do not use results other than the selected file.\n        # answer = data_source[uid]\n        # the uid is the raw index.\n        # print(\"{}:\".format(uid), answer)\n        # print(\"score:\", score)\n        yield index, score\nimport os\nfrom lazero.search.api import lazeroCachePath\nfrom lazero.search.search import updateDataDictWithLineIndexNormalizedScoreAndDivisor\nfrom lazero.search.preprocessing import getFourVersionsOfProcessedLine\ndef txtaiSearch(\n    query,\n    indexDirectory,\n    filter_filepath=None,\n    limit=100,\n    withOriginalLine=True,  # this is default behavior of indexer. you still need to retrieve this flag from tinydb.\n    tinydbDatabasePath=os.path.join(lazeroCachePath, \"index.json\"),\n    dataDict={},\n):\n    divisor = 4 + int(withOriginalLine)\n    fourProcessedLines = list(getFourVersionsOfProcessedLine(query))"
        },
        {
            "comment": "Iterating over search queries and updating data dictionary with index, normalized score, and divisor.",
            "location": "\"/media/root/Toshiba XG3/works/lazero/docs/src/lazero/search/txtai/search.py\":63-79",
            "content": "    for search_query_processed in (\n        [query] if withOriginalLine else []\n    ) + fourProcessedLines:\n        for index, normalized_score in txtaiSearchSingle(\n            search_query_processed,\n            indexDirectory,\n            limit=limit,\n            filter_filepath=filter_filepath,\n        ):\n            dataDict = updateDataDictWithLineIndexNormalizedScoreAndDivisor(\n                dataDict,\n                index,\n                normalized_score,\n                divisor,\n                tinydbDatabasePath=tinydbDatabasePath,\n            )\n    return dataDict"
        }
    ]
}